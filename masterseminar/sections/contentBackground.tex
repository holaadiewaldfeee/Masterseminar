\section{Content Background}\label{content}

In the following, we will consider fault-proneness as already mentioned, but from a restricted point of view, in an object-oriented context. Many software systems in use are based on object-oriented design. This means that data and program code are encapsulated in reusable objects. Everything is based on the communication of objects. For this purpose, classes, interfaces and methods, as well as attributes are declared and thus serve to represent states. This structure alone protects against fault-proneness, since the code is reusable and thus the programming effort is reduced. Thus, fewer errors occur. 

But why should a programmer actually pay attention to fault-proneness at all? For different programming paradigms and programming constructs different rules apply which must be considered in relation to fault-proneness.  The restriction on object orientation is to facilitate the understanding. In addition many principles are contained, which are taken up in other programming concepts again. Thus some conclusions which are drawn here are also differently realizable and applicable to other software concepts.

When software errors are made, it is often not only tedious to find the programming error, but also expensive. When software errors are made, it is often not only tedious to find the programming error, but also expensive. In large systems that are used by many people every day, a small error can cost millions. When software errors are made, it is often not only tedious to find the programming error, but also expensive. In large systems that are used by many people every day, a small error can cost millions. A common misconception is that fault-proneness should only be considered at the end of the software development process. Especially at the beginning of the development you should build the software architecture in a way that it is less error-prone. Changes in the architecture are always more expensive later. In addition, even before the programming itself begins, attention should be paid in the planning to various concepts and metrics, which are shown below.


- fault content, fault proneness, fault prediction background

- relation to other aspects like reliability, correctness, completeness, maintainability etc.

- to what extent can you do analysis now and what should you consider when developing object-oriented

- from the large overall background to the more detailed topic of fault proneness $\rightarrow$ transition to metrics